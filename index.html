<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="About technology and about life.">
<meta property="og:type" content="website">
<meta property="og:title" content="Ice summer bug&#39;s notes">
<meta property="og:url" content="https://summerbuger.github.io/index.html">
<meta property="og:site_name" content="Ice summer bug&#39;s notes">
<meta property="og:description" content="About technology and about life.">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Ice summer bug&#39;s notes">
<meta name="twitter:description" content="About technology and about life.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://summerbuger.github.io/"/>





  <title>Ice summer bug's notes</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ice summer bug's notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://summerbuger.github.io/2018/07/29/hexo-next-github-page/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liam Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPicture.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ice summer bug's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/29/hexo-next-github-page/" itemprop="url">hexo-next-github-page</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-29T00:38:29+08:00">
                2018-07-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/GitHub-Pages/" itemprop="url" rel="index">
                    <span itemprop="name">GitHub Pages</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://summerbuger.github.io/2018/06/21/计算广告-2018-06-21-程序化广告-个性化精准投放实用手册学习笔记1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liam Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPicture.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ice summer bug's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/21/计算广告-2018-06-21-程序化广告-个性化精准投放实用手册学习笔记1/" itemprop="url">程序化广告——个性化精准投放实用手册学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-21T21:00:00+08:00">
                2018-06-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算广告/" itemprop="url" rel="index">
                    <span itemprop="name">计算广告</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="互联网广告发展史"><a href="#互联网广告发展史" class="headerlink" title="互联网广告发展史"></a>互联网广告发展史</h4><ol>
<li>启蒙时代：1993 - 1996年<br>直接将纸媒的广告模式迁移到线上，在页面固定位置放置广告位，广告的形式主要是 <code>Banner 广告位</code>，广告的类型主要是合约广告，广告的计费方式从一开始的按时间包断购买的<code>CPT</code> 逐渐发展出按流量购买的 <code>CPM</code>；</li>
</ol>
<ol start="2">
<li>直销时代：1997 - 2002年<br>直销时代广告的售卖方式还是直接售卖广告位，计费模式还是CPT 或者CPM，广告的形式越来越丰富，出现了<code>弹窗广告</code>、<code>背投广告</code>等广告方式</li>
</ol>
<p><em><em>直销时代和启蒙时代有什么本质区别？？？</em></em></p>
<ol start="3">
<li><p>网盟时代：2003 - 2011年<br>越来越多的媒体让广告主投入越来越多的人力去采买广告，<code>Ad Network(ADN)</code> 将多个媒体（或者其他ADN）打包，按照预定标签标识用户，按照用户标签去批量售卖流量；移动端的广告也在这个时期出现，开发者在网站源代码中添加JS 代码实现WAP 端的广告投放，APP 广告通过嵌入 SDK 代码到App 源代码中实现广告投放；</p>
</li>
<li><p>程序化广告</p>
</li>
</ol>
<p>市场发展过程中，产生了受众定向，推动展示广告的交易模式进化到按受众购买，受众定向的数据来源于<code>Date Manager Platform(DMP)</code>；广告的参与方此时分为 <code>Ad Exchange(ADX)</code> 和 <code>Damend Side Platform(DSP)</code>，  <code>ADX</code> 也对接其他 <code>ADN</code>； 此时广告的交易模式可以分为：<br>a. PDB(programm Direct Pay, 程序化直接购买)： 担保库存、固定价格、广告主私有<br>b. PD(Preferred Deal, 优先交易)：不保证库存，事先出价（固定价格）、广告主私有<br>c. PA(Private Auction, 私有竞价)：不保证库存，RTB竞价、少量广告主<br>d. OA(Open Auction， 公开竞价)：不保证库存，RTB竞价、公开面对所有广告主</p>
<h4 id="程序化广告"><a href="#程序化广告" class="headerlink" title="程序化广告"></a>程序化广告</h4><h5 id="程序化广告的定义"><a href="#程序化广告的定义" class="headerlink" title="程序化广告的定义"></a>程序化广告的定义</h5><p>程序化广告是指利用技术手段进行广告交易和管理的一种广告形态。<br>广告主程序化购买媒体资源、利用算法和技术自动实现精准的目标受众定向；<br>媒体程序化售卖跨媒体、跨终端的媒体资源，利用技术实现广告流量的分级</p>
<ol>
<li>以人为本的精准广告定向</li>
<li>媒体资源的自动化、数字化售卖和采购</li>
</ol>
<h5 id="程序化广告的价值"><a href="#程序化广告的价值" class="headerlink" title="程序化广告的价值"></a>程序化广告的价值</h5><p>传统广告的购买模式，广告主需要逐一和媒体方谈判购买流量；ADN 通过预定义人群标签，打包售卖媒体资源，提高了媒体购买效率。而程序化广告实现了预定义人群定向到自定义人群精准定向的跨越，还能对广告投放进行 <code>频次控制</code>，避免像同一个广告受众反复投放同一个或一组广告；程序化广告还能借助广告验证平台的投放验证，满足广告主对 <code>品牌安全</code>、<code>反作弊过滤</code>、<code>广告可见度分析</code>等方面的要求。</p>
<p>广告主角度</p>
<ol>
<li>效率提升：提高媒体采购效率；提高广告投放效率</li>
<li>效果提升：提高广告投放效率；缩短优化周期</li>
</ol>
<p>媒体角度</p>
<ol>
<li>效率提升：提高媒体资源售卖效率</li>
<li>效果提升：提高流量利用率和用户体验</li>
</ol>
<h5 id="中国程序化广告发展阶段分析"><a href="#中国程序化广告发展阶段分析" class="headerlink" title="中国程序化广告发展阶段分析"></a>中国程序化广告发展阶段分析</h5><ol>
<li>2010 - 2011年：萌芽期<br>阿里妈妈推出全网的广告交易平台 <code>Tanx</code></li>
<li>2012 - 2013年：探索期<br>DSP 市场起步阶段；ADX 如雨后春笋</li>
<li>2014 - 2016年：燥热期<br>DSP、ADX 大量出现; DMP 越来越智能；市场过度膨胀应发了程序化广告的泡沫，行业存在一系列<code>不规则</code>的玩法, 通过各种作弊造价的方式获取广告主预算</li>
</ol>
<p><em><em>有哪些不规则的玩法？？？</em></em></p>
<ol start="4">
<li>2017 - 2018年：洗牌期<br>市场过度膨胀之后，行业逐渐回归有序。</li>
</ol>
<p>广告主的变化</p>
<ol>
<li>透明程序化的诉求：流量、数据环节透明化；财务和合同等流程的规范化、严谨化</li>
<li>盘活私有数据：广告主自建 DSP、DMP</li>
<li>更加合理的KPI衡量标准：严格把关广告的流量消耗，杜绝作弊</li>
</ol>
<p>媒体的变化</p>
<ol>
<li>掌握流量控制权：自建ADX/SSP</li>
<li>完善广告交易模式：升级PA、PD、PDB 交易模式的技术支持</li>
<li>广告形式更加丰富：媒体形式越来越多，原生广告、可玩广告、短视频广告等广告形式的出现</li>
</ol>
<p><em>可玩广告：游戏类APP短时间试玩游戏的广告形式</em></p>
<ol start="5">
<li>2019 年之后：成熟期<br>市场规模到达瓶颈，程序化广告格局相对稳定。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://summerbuger.github.io/2018/05/21/技术-etcd-2018-05-21-etcd安装使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liam Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPicture.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ice summer bug's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/21/技术-etcd-2018-05-21-etcd安装使用/" itemprop="url">etcd 使用入门</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-21T21:00:00+08:00">
                2018-05-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/etcd/" itemprop="url" rel="index">
                    <span itemprop="name">etcd</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="etcd-使用入门"><a href="#etcd-使用入门" class="headerlink" title="etcd 使用入门"></a>etcd 使用入门</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>介绍 etcd 和 raft协议</p>
<h3 id="etcd-安装"><a href="#etcd-安装" class="headerlink" title="etcd 安装"></a>etcd 安装</h3><p>etcd 的安装有两种方式</p>
<ol>
<li>直接从<a href="&quot;https://github.com/coreos/etcd/releases/&quot;" title="release binary page">官网</a>下载 release 版本的二进制文件</li>
<li>下载源码手动编译安装</li>
</ol>
<p>个人倾向于使用 release 版本安装，下面开始下载安装</p>
<ol>
<li><p>找到下载的压缩包，解压</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip etcd-v3.3.8-darwin-amd64.zip</span><br></pre></td></tr></table></figure>
</li>
<li><p>将解压的文件夹的移动到安装目录中</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mv /path/to/etcd /usr/<span class="built_in">local</span>/etcd</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>此时我们可以先看看解压后有什么？</p>
<pre><code>➜  etcd-v3.3.8-darwin-amd64 ll
total 113064
drwxr-xr-x  22 ?  staff   748B  6 16 00:55 Documentation
-rw-r--r--   1 ?  staff    38K  6 16 00:55 README-etcdctl.md
-rw-r--r--   1 ?  staff   7.1K  6 16 00:55 README.md
-rw-r--r--   1 ?  staff   7.7K  6 16 00:55 READMEv2-etcdctl.md
drwx------   3 ?  staff   102B  7 16 23:45 default.etcd
-rwxr-xr-x   1 ?  staff    30M  6 16 00:55 etcd
-rwxr-xr-x   1 ?  staff    25M  6 16 00:55 etcdctl
</code></pre><p>可以看到这里有两个可执行程序: <code>etcd</code> 和 <code>etcdctl</code></p>
<p><code>etcd</code>: etcd 服务端程序<br><code>etcdctl</code>: etcd 客户端程序</p>
<ol start="3">
<li>启动程序</li>
</ol>
<p>3.1 使用默认配置启动程序</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./etcd</span><br></pre></td></tr></table></figure>
<p>3.2 来一个配置文件</p>
<p><em><em>待补充</em></em></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://summerbuger.github.io/2018/05/16/技术-golang-2018-05-16-golang-GC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liam Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPicture.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ice summer bug's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/16/技术-golang-2018-05-16-golang-GC/" itemprop="url">golang GC</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-16T21:00:00+08:00">
                2018-05-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/golang/" itemprop="url" rel="index">
                    <span itemprop="name">golang</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="golang-GC-浅谈"><a href="#golang-GC-浅谈" class="headerlink" title="golang GC 浅谈"></a>golang GC 浅谈</h3><p>Garbage collector (GC).</p>
<pre><code>The GC runs concurrently with mutator threads, is type accurate (aka precise), allows multiple GC thread to run in parallel. It is a concurrent mark and sweep that uses a write barrier.
</code></pre><p>golang 的 GC 和工作线程并行运行，<em>?类型准确？</em>，允许多个GC 线程并发运行, 通过 <code>write barrier</code> 实现并发的标记清除。</p>
<pre><code>It is non-generational and non-compacting. Allocation is done using size segregated per P allocation areas to minimize fragmentation while eliminating locks in the common case.
</code></pre><p>golang GC 不分代，不压缩。 golang 在分配内存的时候是预先将内存划分为固定大小的内存块，以尽量减少碎片，同时消除常见情况下的锁定。</p>
<pre><code>The algorithm decomposes into several steps.
This is a high level description of the algorithm being used. For an overview of GC a good place to start is Richard Jones&apos; gchandbook.org.

The algorithm&apos;s intellectual heritage includes Dijkstra&apos;s on-the-fly algorithm, see
Edsger W. Dijkstra, Leslie Lamport, A. J. Martin, C. S. Scholten, and E. F. M. Steffens. 1978.
On-the-fly garbage collection: an exercise in cooperation. Commun. ACM 21, 11 (November 1978),
966-975.
For journal quality proofs that these steps are complete, correct, and terminate see
Hudson, R., and Moss, J.E.B. Copying Garbage Collection without stopping the world.
Concurrency and Computation: Practice and Experience 15(3-5), 2003.


1. GC performs sweep termination.

a. Stop the world. This causes all Ps to reach a GC safe-point.

b. Sweep any unswept spans. There will only be unswept spans if this GC cycle was forced before the expected time.

1. GC

2. GC performs the &quot;mark 1&quot; sub-phase. In this sub-phase, Ps are
allowed to locally cache parts of the work queue.

     a. Prepare for the mark phase by setting gcphase to \_GCmark
     (from \_GCoff), enabling the write barrier, enabling mutator
     assists, and enqueueing root mark jobs. No objects may be
     scanned until all Ps have enabled the write barrier, which is
     accomplished using STW.

     b. Start the world. From this point, GC work is done by mark
     workers started by the scheduler and by assists performed as
     part of allocation. The write barrier shades both the
     overwritten pointer and the new pointer value for any pointer
     writes (see mbarrier.go for details). Newly allocated objects
     are immediately marked black.

     c. GC performs root marking jobs. This includes scanning all
     stacks, shading all globals, and shading any heap pointers in
     off-heap runtime data structures. Scanning a stack stops a
     goroutine, shades any pointers found on its stack, and then
     resumes the goroutine.

     d. GC drains the work queue of grey objects, scanning each grey
     object to black and shading all pointers found in the object
     (which in turn may add those pointers to the work queue).
</code></pre><p><code>write barrier</code>: 写屏障</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://summerbuger.github.io/2018/05/14/计算广告-2018-05-14-重读计算广告/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liam Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPicture.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ice summer bug's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/14/计算广告-2018-05-14-重读计算广告/" itemprop="url">重读计算广告</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-14T21:00:00+08:00">
                2018-05-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算广告/" itemprop="url" rel="index">
                    <span itemprop="name">计算广告</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>看了一遍刘鹏老师的《计算广告》，获益匪浅，但是部分地方还是不够明确，决定重读一番，学习笔记记录如下，如有错漏敬请斧正。</p>
<h3 id="在线广告"><a href="#在线广告" class="headerlink" title="在线广告"></a>在线广告</h3><p>在线广告开创了以人群为投放目标，以产品为导向的技术型投放模式，得到了广告主的青睐。在线广告开启了大规模自动化的利用数据改善产品和提高收入的先河，提供了一种盈利模式。</p>
<h4 id="什么是大数据"><a href="#什么是大数据" class="headerlink" title="什么是大数据"></a>什么是大数据</h4><p>如果有的数据处理问题无法通过数据采样的方法来降低温处理的复杂程度，就必须利用一些专门为海量数据处理而设计的计算和存储技术来实现。</p>
<p>大数据问题的 <code>4V特征</code></p>
<ol>
<li>Volume (规模)</li>
<li>Variety (多样性)</li>
<li>Velocity (高速)</li>
<li>Value (价值)</li>
</ol>
<p>大数据问题的特征：当数据的采用率的递增叫显著提升解决问题的效果，而且两者基本成正比，这就是典型的大数据问题。</p>
<h4 id="为什么要学习计算广告"><a href="#为什么要学习计算广告" class="headerlink" title="为什么要学习计算广告"></a>为什么要学习计算广告</h4><p>计算广告作为目前最成熟的得到充分商业化和规模化的大数据应用<br>1） 提供了规模化的将用户行为数据转为可衡量的商业价值的完整产品线和解决方案；<br>2） 孕育和孵化了较为成熟的数据加工和交易产业链，并对其中的<code>用户隐私</code>边界有深入的探讨；<br>3） 由于商业上的限制条件，计算广告的技术和产品逻辑比个性推荐更加复杂周密；</p>
<h4 id="什么是广告"><a href="#什么是广告" class="headerlink" title="什么是广告"></a>什么是广告</h4><pre><code>广告是由已经确定的`出资人`通过各种`媒介`进行的有关产品（商品、服务和观点）的，通常是有偿的、有组织的、综合的、劝服性的非人员的信息传播活动。
                                                                                                    ————《当代广告学》
</code></pre><p>这个定义中有两个主动参与方 ———— <code>出资人</code> 和 <code>媒介</code>, 还有一个被动的参与方, 被劝服的广告的观看者。在计算广告中术语分别是：<code>需求方(Demand)</code>(广告主、广告主代理商、其他形式的采买方)、<code>供给方(Supply)</code>(媒体、其他形式的变现平台)、 <code>广告受众(Adversiter)</code></p>
<p>传统广告主要是电视、报纸广告，在大量投放和优化效果广告的能力显然是缺乏的，只能是宣传品牌形象、提升中长期购买率和利润空间；而在线广告可以实现低成本的投放个性化广告，而且部分数字数字（如搜索、电子商务）可以明确的知道用户的意图，能够很好的优化广告效果。</p>
<p><em><em>广告的根本目的是<code>广告主</code>通过<code>媒体</code>达到<code>低成本</code>的<code>用户</code>接触</em></em></p>
<p>这个定义中的 <code>底成本</code> 需要一个评价指标，这就是 ———— <code>投入产出比（Return On Investment, ROI）</code>，即某次广告活动的总产出与总投入的比例。总投入很容易确定，但是总产出无法确定，但是我们我们也可以通过对各个广告渠道的对比，评估广告成本是否令人满意。</p>
<pre><code>一切付费的信息、产品或服务的传播渠道，都是广告。
</code></pre><h4 id="在线广告创意类型"><a href="#在线广告创意类型" class="headerlink" title="在线广告创意类型"></a>在线广告创意类型</h4><blockquote>
<p>横幅广告</p>
<p>文字链接广告</p>
<p>富媒体广告</p>
<p>视频广告</p>
<blockquote>
<p>前插片广告： 视频播放前的</p>
<p>暂停广告：视频播放中，暂停时播放的广告</p>
</blockquote>
<p>社交广告：社交产品中的原生广告</p>
<p>移动广告</p>
<p>邮件定向营销广告</p>
</blockquote>
<h4 id="在线广告简史"><a href="#在线广告简史" class="headerlink" title="在线广告简史"></a>在线广告简史</h4><p>在线媒体出现并发展到一定的流量规模之后，就在页面上直接插入广告位，这种照搬报纸广告在互联网上展示广告的产品形式称为 <code>展示广告(display advertising)</code> , 而售卖广告的模式是采用合同的方式确定某一广告位在某一时间段为某特定广告主所独占，并且根据双方的要求，确定广告创意和投放策略，称为 <code>合约广告</code>。</p>
<p>随着在线媒体的流量快速增长以及在线广告逐渐被广告主了解接受，在线媒体提价的行为被接受，但是媒体流量和品牌认知度都相对稳定之后，提价就不再是提高收入的合适方案了。<br>但是很快在线广告不同于传统媒体广告的本质特点就被发现了：<br><em><em>在线广告可以对不同的广告受众展示不同的广告创意</em></em></p>
<p>这种广告投放的方式就是 <code>定向广告(trageted advertising)</code>。 而要做到这一点，首先要从技术上获取用户的属性标签，例如用户的性别、年龄等标签，这就是<code>受众定向</code>；而且这时候的广告不能再是静态的嵌入到网页中，而是响应前端的实时请求，根据用户标签自动选择并返回合适的广告， 这就是 <code>广告投放(ad serving)</code>。<br>此时广告的售卖方式还是以合同的形式进行，并且在合同中注明媒体需要保证广告的投放量以及投放量未完成时赔偿方案。这种<code>合约广告</code>的交易方式被称为<code>担保式投放（Guaranteed Delivery）</code>, 这种合约还是主要面对品牌广告主，计费方式是<code>按千次展示收费(Cost per Mille, CPM)</code>。</p>
<p>合约广告有两个技术难点：</p>
<ol>
<li>各个合约的目标受众会有交叉覆盖，如何有效的将流量分配到交叉覆盖上；</li>
<li>在在线环境下实时的完成每一次展示决策；<br>这两个难点的问题称为 <code>在线分配</code>， 可以使用 <code>带约束优化</code> 的数学框架来探索这个问题。</li>
</ol>
<p><code>定向投放</code>的目的是供给方为了<code>拆分流量</code>提高营收，但是<em>如果一开始就提供非常精细的定向，反而会造成售卖率下降</em>，品牌广告主都喜欢优质的流量，如果定向十分精确了略差的流量就卖不出去了。</p>
<p><code>受众定向</code>的产生使得市场发展呈现两个趋势</p>
<ol>
<li>定向标签越来越精准；</li>
<li>广告主的数量不断膨胀；</li>
</ol>
<p>上述两个趋势增加了 <code>在线分配</code> 问题的处理难度，降低了流量的变现能力。从业者开始考虑放弃量的保证，供给方只向广告主保证单位流量的成本，对每次展现都基本按照收益最高的原则来决策，这就是 <code>竞价广告</code>。</p>
<p><code>竞价广告</code> 的产生原因如上，然而现实中它的出现来自于 <code>搜索广告</code>，<code>搜索引擎</code>的关键词就是一个精准的定向，很自然的就采用的竞价的售卖方式<br>将搜索关键词换成浏览页面中的关键词就成了 <code>上下文广告</code>（信息流广告的鼻祖）</p>
<p>从宏观市场上看 <code>竞价广告</code> 摆脱了 <code>合约广告</code> 中合约的约束，让广告主能够充分竞争；但是微观上的最优方案并不是整个市场的最大收益。竞价机制的发展，诞生了 <code>广义第二高价 (Generalized Second Price, GSP)</code> 竞价理论。</p>
<p>有了竞价机制和受众定向，不被品牌广告主看好的中小互联网媒体将流量打包给一个组织，组织将媒体资源按照人群或者上下文标签打包售卖，用竞价的方式决定流量分配。这个组织就是 ———— <code>广告网络(ad Network, ADN)</code>。 <code>ADN</code> 采用的计费方式一般是 <code>按点击收费(Cost Per Click, CPC)</code>。最重要的是，ADN 的出现使得不受品牌广告主青睐的比较差流量有了变现的途径。</p>
<p>ADN 只通过出价接口提供价格约定，那么由谁来保证量呢？这就催生了一种需求方产品；此时流量采买发生了几点变化：</p>
<ol>
<li>流量采买更多的面向受众而非媒体或广告位进行采买；</li>
<li>需求方产品需要通过技术手段保证广告主量的要去，并在此基础上帮助广告主优化效果。</li>
</ol>
<p><em>问题：ADN 的竞价流程是什么样的？</em></p>
<p>AND 定义好定向标签，将流量分类打包出售，而不会去控制每次展示的出价；需求方选择了合适的标签组合并阶段性的调整出价来间接控制效果。而需求方产品对接多个 ADN 或媒体按人群一站式采买广告并优化投入产出比，这就是 <code>交易终端(Trading Desk, TD)</code>。</p>
<p>ADN 将媒体的广告受众打上了用户标签，然后批量售卖，但这不能满足需求方越来越明确的利益要求。例如：某电商需要通过给它的忠实用户投放广告来推广某产品，此时需求方需要按照自己的人群定义来挑选流量；流量拍卖的过程从广告主预先出价批量购买，变成了每次展示时实时出价，媒体方提供广告展示的页面的上下文页面URL和用户标识等信息给需求方，需求方就可以完成定制化的人群选择和出价，这就是 <code>实时竞价(Real Time Bidding, RTB)</code>。市场诞生了一个聚合大量媒体的剩余流量并且采用实时竞价方式为他们变现的产品形态 ———— <code>广告交易平台（ad Exchange, ADX）</code>。</p>
<p>通过实时竞价的方式，按照定制化的人群标签购买广告，这样的产品就是<code>需求方平台(Demand Side Platform, DSP)</code>。<code>DSP</code> 需要尽可能准确地估计每次展示带来的期望价值，而因为充分的环境信息使得深入计算和估计成为可能。基于 <code>DSP</code> 的广告采买方式叫作 <code>程序化交易(programmatic trade)</code>, 除了 <code>RTB</code> 外还有 <code>优选(perfered deals)</code> 以及 <code>私有交易市场(Private Market Place, PMP)</code>。</p>
<p>在在线广告的发展历史上，定向技术和交易形式的进化是一条主线。从固定位置合约交易到受众定向、担保投放，再到竞价交易方式，最后发展成开放的实时竞价交易市场。这一主线的核心驱动力是越来越多的数据源为广告决策提供支持，从而提升广告的效果。广告发展的另外一条主线是产品展现逻辑上的发展：从广告位和内容相对独立，到通过搜索广告认识到内容和广告对立起来未必是好的选择，搜索广告和信息流广告突出的效果就是因为内容的展现和触发逻辑高度一致，因此产生了将内容和广告以某种方式统一决策或排序的广告产品 ———— <code>原生广告</code>。<code>原生广告</code> 的思路在移动设备上很有前景。</p>
<h4 id="泛广告商业产品"><a href="#泛广告商业产品" class="headerlink" title="泛广告商业产品"></a>泛广告商业产品</h4><p><code>泛广告商业产品</code> 的本质都是 <code>付费推广</code>，这些付费推广模式的表现方式更加多样化，用户的感知程度和参与程度也大不相同，但是产品的销售模式却与狭义的广告基本相同，但这些商业产品本质上也是在线广告。</p>
<ol>
<li>团购</li>
<li>游戏联运</li>
<li>固定位导航</li>
<li>返利购买</li>
</ol>
<h3 id="计算广告基础"><a href="#计算广告基础" class="headerlink" title="计算广告基础"></a>计算广告基础</h3><p>计算广告的主要特点有 <code>可衡量的效果</code>以及相应的<code>计算优化</code>。</p>
<p>利润优化问题的概念框架</p>
<p>广告产品的收入衡量指标,也是计算广告中最核心的可衡量指标 ———— <code>千次展现期望收入(eCPM, excepted Cost Per Mille)</code>。<br><code>eCPM</code> 可分解为 <code>点击率(Click Through Rate, CTR)</code> 和 <code>点击价值</code></p>
<p>在线广告产品有很多种计费方式，不同的计费方式反映了不同的市场分工; 也就是说供给方和需求方如何分工估计点击率和点击价值，与整个市场的资源优化配置有关。</p>
<h4 id="广告信息接收过程"><a href="#广告信息接收过程" class="headerlink" title="广告信息接收过程"></a>广告信息接收过程</h4><ol>
<li>曝光：广告在页面上展示了</li>
<li>关注： 广告受众关注到了页面上的广告</li>
<li>理解： 广告受众理解了广告的诉求</li>
<li>接受： 广告表达的诉求得到广告受众的认同</li>
<li>保持： 追求长期转化的品牌广告，希望传达的信息给用户留下深刻的印象</li>
<li>决策： 广告最终带来的实际转化行为，例如购买</li>
</ol>
<h4 id="互联网广告的技术特点"><a href="#互联网广告的技术特点" class="headerlink" title="互联网广告的技术特点"></a>互联网广告的技术特点</h4><ol>
<li>技术和计算导向： 数字媒体的特点使得在线广告可以进行精确的受众定向；“由于在线广告有独特的竞价交易方式，可以对广告效果进行有效的预估和优化”。</li>
<li>效果的可衡量性： 广告的展示、点击数据直接可以衡量广告的效果</li>
<li>创意和投放方式的标准化：标准化的驱动力来自于受众定向和程序化购买</li>
<li>媒体概念的多样化：数字媒体的交互功能越来越丰富多彩，和线下媒体已经有了本质差别。不同在线媒体在转化的链条上位置不一样，有些更接近最后的决策，有些是为了吸引潜在用户。</li>
<li>数据驱动的投放决策：在线广告是目前最成熟的大数据引用。在线广告投放流程是：广泛收取用户的行为数据和广告反馈数据，利用云计算基础设施给用户打上合适的标签，同样根据数据在多个广告竞争同一次展示是作出决策，再将投放结果的统计数据反馈广告操作人员以调整投放策略。</li>
</ol>
<h4 id="计算广告的核心问题"><a href="#计算广告的核心问题" class="headerlink" title="计算广告的核心问题"></a>计算广告的核心问题</h4><pre><code>计算广告的核心问题，是为一系列用户和环境的组合找到最适合的广告投放策略以优化整体广告活动的利润。
</code></pre><p>上述问题的公式化</p>
<p>max E (ri - qi)</p>
<p>其中 i 表示从第 1 次到第 T 次之间的一次广告展示。优化目标是在这 T 次展示的总收入(r)与总成本(q)的差。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://summerbuger.github.io/2018/03/01/技术-golang-2018-03-01-golang基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liam Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPicture.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ice summer bug's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/01/技术-golang-2018-03-01-golang基础/" itemprop="url">golang 基础学习笔记（-）———— 基本语法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-01T21:00:00+08:00">
                2018-03-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/golang/" itemprop="url" rel="index">
                    <span itemprop="name">golang</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Go-基础语法"><a href="#Go-基础语法" class="headerlink" title="Go 基础语法"></a>Go 基础语法</h2><h3 id="Go-程序的基本构成"><a href="#Go-程序的基本构成" class="headerlink" title="Go 程序的基本构成"></a>Go 程序的基本构成</h3><h4 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"hello, world"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Go 程序的基本构成，每个程序都有自己所在的 <code>package</code>,  <code>包</code>这个概念类似于其他编程语言的<code>命名空间</code> 或者 <code>库名</code>, 一般用一个简单的单词，与其他功能区分开即可, 命名规范要求全小写，或者<code>&#39;_&#39;</code>连接的多个单词</p>
<p>Go 程序是通过 <code>import</code> 关键字将一组包链接在一起。<br><code>import &quot;fmt&quot;</code> 表示该程序需要使用 <code>package fmt</code>（函数或者其他元素），其中 “fmt” 是一个包名</p>
<p>格式是</p>
<ul>
<li>import “package_name”</li>
<li>import<br>(<br><br>  “package_name”<br><br>)</li>
</ul>
<h4 id="function"><a href="#function" class="headerlink" title="function"></a>function</h4><p>Go 程序的重要组成部分是函数，格式是 <code>func 函数名(参数列表) (返回值列表) {}</code></p>
<h4 id="main-main"><a href="#main-main" class="headerlink" title="main.main"></a>main.main</h4><p>Go 程序的入口是 <code>main.main</code> 方法, 第一个<code>main</code>是该程序的 <code>package</code>; 第二个 <code>main</code> 是该程序的 <code>main</code> 函数，<code>main</code> 函数要求没有参数列表和返回值列表。</p>
<h3 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h3><h4 id="int"><a href="#int" class="headerlink" title="int"></a>int</h4><p>包含int8, int16, int32, int64，分别8bit, 16bit, 32bit, 64bit的有符号整数，而int类型占的bit数决定于编译环境所在平台的位数，如果是32位环境则是32bit，如果是64位环境则是64bit。<br>除了有符号数之外还要无符号数，Go 语言中，无符号型整数有 uint8, uint16, uint32, unit64， int8 的取值范围是 [-128~127], 而uint8的取值范围是 [0~255], 其他有符号型和无符号型整数的取值范围和这个类型类似。</p>
<h4 id="byte"><a href="#byte" class="headerlink" title="byte"></a>byte</h4><pre><code>byte is an alias for uint8 and is equivalent to uint8 in all ways. It is used, by convention, to distinguish byte values from 8-bit unsigned integer values.
</code></pre><p>byte 是 <code>uint8</code> 的别名（alias）， 或者说完全等同于 <code>uint8</code>。按照惯例用于区分8bit无符号数和byte 类型数据</p>
<h4 id="rune"><a href="#rune" class="headerlink" title="rune"></a>rune</h4><pre><code>rune is an alias for int32 and is equivalent to int32 in all ways. It is used, by convention, to distinguish character values from integer values.
rune 是 `int32` 类型的别名, 或者说完全等同于 `int32`. 按照惯例用于区分字符类型和整数类型
</code></pre><p><code>rune</code> 用数字表示字符的 <code>ASCII</code>编码</p>
<h4 id="float"><a href="#float" class="headerlink" title="float"></a>float</h4><p>浮点类数据类型包含<code>float32</code>和<code>float64</code>, Go 语言基于 <code>IEEE 754标准</code>实现的浮点类型数据，具体参见另一篇文章<a href="http://baidu.com" target="_blank" rel="noopener">浮点数</a></p>
<h4 id="bool"><a href="#bool" class="headerlink" title="bool"></a>bool</h4><p>布尔类型数据，取值有 true 和 false</p>
<h4 id="complex"><a href="#complex" class="headerlink" title="complex"></a>complex</h4><p>复数，有对应<code>float32</code> 和 <code>float64</code> 两个精度的数据类型 <code>complex64</code> 和 <code>complex128</code>,<br><code>complex(1, 2)`</code> 等同于  <code>1 + 2i</code></p>
<h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><p>字符串类型，底层实现是byte 类型的 slice，不可变（immutable）</p>
<h4 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="literal">iota</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><code>iota</code> 是无类型的int 类型的常量计数器，在const关键字出现时配置为0，从0开始，const 中每增加一行iota 自增一次（+1）</p>
<p><code>iota</code> 的使用示例如下, 在 <code>const</code> 关键字修饰的括号中， <code>iota</code> 首先被重置成0， 然后 a = 0, b = 1, c = 2</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	a = <span class="literal">iota</span> <span class="comment">// 0</span></span><br><span class="line">  b        <span class="comment">// 1</span></span><br><span class="line">	c        <span class="comment">// 2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>从上面的特性来看，我们可以使用 <code>iota</code> 来定义一个简单的<code>枚举</code>，来个小例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type chargeType int</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">	CPC  chargeType = iota // 0</span><br><span class="line">	CPM                    // 1</span><br><span class="line">	CPT                    // 2</span><br><span class="line">	CPD                    // 3</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>设想你在处理消费者的音频输出。音频可能无论什么都没有任何输出，或者它可能是单声道，立体声，或是环绕立体声的。<br>这可能有些潜在的逻辑定义没有任何输出为 0，单声道为 1，立体声为 2，值是由通道的数量提供。<br>所以你给 Dolby 5.1 环绕立体声什么值。<br>一方面，它有6个通道输出，但是另一方面，仅仅 5 个通道是全带宽通道（因此 5.1 称号 - 其中 .1 表示的是低频效果通道）。<br>不管怎样，我们不想简单的增加到 3。<br>我们可以使用下划线跳过不想要的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">type AudioOutput int</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">	none  AudioOutput = iota // 0</span><br><span class="line">	mone                    // 1</span><br><span class="line">	stereo                  // 2</span><br><span class="line">	_</span><br><span class="line">	_</span><br><span class="line">	Dolby                   // 5</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h3><h4 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h4><p>基础用法<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition &#123;</span><br><span class="line">	<span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> condition &#123;</span><br><span class="line">	<span class="comment">// do something</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> condition1 &#123;</span><br><span class="line">	<span class="comment">// do something</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> condition2 &#123;</span><br><span class="line">	<span class="comment">// do something</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>关键字 if 和 else 之后的左大括号 { 必须和关键字在同一行，如果你使用了 else-if 结构，则前段代码块的右大括号 } 必须和 else-if 关键字在同一行。这两条规则都是被编译器强制规定的。</em></p>
<p>除了上述情况之外还有如下使用方法<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> initialization; condition &#123;</span><br><span class="line">	<span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Example:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> i := getValue(); i &gt; <span class="number">10</span> &#123;</span><br><span class="line">	<span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><ol>
<li>常见用法</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; count; i++ &#123;</span><br><span class="line">	<span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>go 中没有while 循环，用for 循环代替</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i &lt; <span class="number">100</span> &#123;</span><br><span class="line">	<span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>无限循环，没有 condition</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>或<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index := <span class="number">0</span>; ; index ++ &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="4">
<li><code>for range</code></li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> idx, element := <span class="keyword">range</span> intArr &#123; <span class="comment">// idx 是数组下表，element 是数组下标所在元素</span></span><br><span class="line">	<span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> idx := <span class="keyword">range</span> intArr &#123; <span class="comment">// idx 是数组下表</span></span><br><span class="line">	<span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>注意：<code>for a := range arr</code> 这种遍历的时候 a 是数组下标</em></p>
<p>或<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> map1 &#123; <span class="comment">// Key map 中的key value 是map 中的值</span></span><br><span class="line">	<span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="5">
<li><code>break</code> 和 <code>continue</code></li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> idx := <span class="number">0</span> ;; idx ++ &#123;</span><br><span class="line">	<span class="keyword">if</span> idx &gt; <span class="number">10</span> &#123;</span><br><span class="line">		<span class="keyword">break</span>; <span class="comment">// 退出当前for 循环</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> idx := <span class="number">0</span> ;; idx ++ &#123;</span><br><span class="line">	<span class="keyword">if</span> (idx % <span class="number">2</span>) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">continue</span>; <span class="comment">// 进入下一个循环</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="switch-case"><a href="#switch-case" class="headerlink" title="switch case"></a>switch case</h4><p>相比其他语言来说go 语言的 <code>switch case</code> 更强大，它支持各种形式的表达式，而且匹配上一个 <code>case</code> 执行完分支代码后，程序会自动switch代码块，不需要使用 <code>break</code> 标明结束</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> var1 &#123;</span><br><span class="line"><span class="keyword">case</span> val1:</span><br><span class="line">	<span class="comment">// do something</span></span><br><span class="line"><span class="keyword">case</span> val2:</span><br><span class="line">	<span class="comment">// do something</span></span><br><span class="line"><span class="keyword">default</span>:  <span class="comment">// 不符合之前所有已给出条件的时候走到这里，建议写到最后</span></span><br><span class="line">	<span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面例子中<code>var1</code> 可以是<code>任何类型</code>， 而 <code>val1</code> 和 <code>val2</code> 是同类型的任意值</p>
<p>多个case 合并</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> i &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>, <span class="number">2</span>:</span><br><span class="line">	<span class="comment">//do something</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">	<span class="comment">//do something</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">	<span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>or<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> i &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">	<span class="comment">//do something</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">	<span class="comment">//do something</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">	<span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>fallthrough</code></p>
<p>当执行完一个 <code>case</code> 分支后还想继续执行下一个 <code>case</code> 分支，可以使用关键字 <code>fallthrough</code></p>
<p>example：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i = <span class="number">2</span></span><br><span class="line">	<span class="keyword">switch</span> i &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		fmt.Printf(<span class="string">"Value 1 or 0, val:%v \n"</span>, i)</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		fmt.Printf(<span class="string">"Value 2, val:%v \n"</span>, i)</span><br><span class="line">		<span class="keyword">fallthrough</span></span><br><span class="line">	<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">		fmt.Printf(<span class="string">"Value 3, val:%v \n"</span>, i)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Printf(<span class="string">"Value default, val:%v \n"</span>, i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure>
<p>上面程序的输出结果是：</p>
<pre><code>Value 2, val:2
Value 3, val:2

Process finished with exit code 0
</code></pre><h4 id="array-数组"><a href="#array-数组" class="headerlink" title="array 数组"></a>array 数组</h4><p>数组是固定长度的同一类型元素组成的序列，可以通过数组下标访问来访问元素，下标从0开始</p>
<p>数组的长度是数组类型的一个组成部分，因此[3]int和[4]int是两种不同的数组类型，数组的长度必须是常量表达式，因为数组的长度需要在编译阶段确定。</p>
<p>golang 提供内建函数 <code>append(arr []Type, element... Type)</code> 用于往数组中添加元素，也可用于 <code>slice</code><br>数组相关的<code>内建函数</code> 还有 <code>len()</code> 和 <code>cap()</code>, 对于数组而言 <code>len()</code> 和 <code>cap()</code> 是一样的</p>
<p><code>len()</code> 函数的参数也可以是 nil, <em>len(nil) == 0</em></p>
<p>数组的声明格式是<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [length]Type</span><br></pre></td></tr></table></figure></p>
<p>刚声明的数组长度是 length，每个元素都是零值（数字是0， 字符串是’’，引用类型是nil）<br>也可以使用 <code>make</code> 定义一个数组</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="built_in">make</span>([]Type, <span class="built_in">len</span>)</span><br></pre></td></tr></table></figure>
<p>还可以在定义的是时候设定初始值<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>]<span class="keyword">int64</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>或者设定指定下标的元素<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>]<span class="keyword">int64</span>&#123;<span class="number">2</span>:<span class="number">1000</span>&#125;  <span class="comment">// arr := []int64&#123;0, 0, 1000&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>如果数组元素本身可以比较的，那么数组也是可以用 <code>==</code> 比较的，反则会编译失败</p>
<h4 id="slice（切片）"><a href="#slice（切片）" class="headerlink" title="slice（切片）"></a>slice（切片）</h4><p><code>slice(切片)</code> 是对数组的一个连续片段的使用</p>
<p>切片也是可索引的，也可以使用 <code>len()</code> 函数的来获取长度<br>切片除了长度之外，还有一个属性是容量， 通过内建函数 <code>cap()</code> 函数来获取容量，容量的含义是切片开始位置到底层数组结束位置的数组长度<br>例如切片 s 是数组 a 的一部分，s = a[3:], 那么 <em>cap[s] = len(a) - 3</em><br>对于切片来说，始终需要保证 <code>0 &lt;= len(s) &lt;= cap(s)</code>， 如果 <em>len(s) &gt; cap(s)</em> 就会出现<code>越界异常</code></p>
<p>从上面这段文字总结出 <code>slice</code> 的组成元素是：</p>
<ol>
<li>指针（指向底层数组中切片的第一个元素）</li>
<li>长度</li>
<li>容量</li>
</ol>
<p>下图描述了切片的构成<br><img src="/assets/picture/slice.png" alt="图片" title="slice 构成"></p>
<p>slice 的初始化方式是<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice1 [...]Type    <span class="comment">// 不需要指明长度，编译器会自动构建一个长度合适的底层数组</span></span><br><span class="line"><span class="keyword">var</span> slice2 []Type       <span class="comment">// _..._可以不写</span></span><br><span class="line"><span class="keyword">var</span> arr [length]Type    <span class="comment">// 声明一个数组</span></span><br><span class="line">slice3 := arr[start:end] <span class="comment">// 声明一个由数组中 [start, end) 元素组成的切片</span></span><br><span class="line">slice4 := arr[start:]    <span class="comment">// end 可以省略不写，表示 end = len(arr)声明一个由数组中 [start, len(arr)) 元素组成的切片</span></span><br><span class="line">slice5 := arr[:end]      <span class="comment">// start 可以省略不写，表示 start = 0 声明一个由数组中 [0, end) 元素组成的切片</span></span><br><span class="line">slice6 := <span class="built_in">make</span>([]Type, <span class="built_in">len</span>, <span class="built_in">cap</span>)  <span class="comment">// 声明一个具体类型，长度是len，容量是cap 的切片， make 关键字适用于 array, slice, map, channel 的内存分配</span></span><br><span class="line">slice7 := <span class="built_in">new</span>([]Type)  <span class="comment">// 也可以用 new 关键词定义一个 len == cap == 0 的slice，但是返回一个指向类型为 T，值为 0 的地址的指针，它适用于值类型如数组和结构体；它相当于 &amp;T&#123;&#125;。强烈建议不要使用 new 关键字声明 slice</span></span><br></pre></td></tr></table></figure></p>
<p>由于<code>slice</code> 是共享的底层数组，当一个slice 改变了底层数组的时候，和它共享底层数组的其他<code>slice</code> 也会受影响</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> arr [<span class="number">6</span>]<span class="keyword">int64</span></span><br><span class="line">	<span class="keyword">for</span> idx := <span class="keyword">range</span> arr &#123;</span><br><span class="line">		arr[idx] = <span class="keyword">int64</span>(idx + <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"The underlying array:%v \n"</span>, arr)</span><br><span class="line"></span><br><span class="line">	s := arr[<span class="number">3</span>:<span class="number">5</span>]</span><br><span class="line">	fmt.Printf(<span class="string">"The slice:%v, length:%v, capacity:%v \n"</span>, s, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line"></span><br><span class="line">	s[<span class="number">0</span>] = <span class="number">1000</span></span><br><span class="line">	fmt.Printf(<span class="string">"The underlying array after set value for slice :%v \n"</span>, arr)</span><br><span class="line">	fmt.Printf(<span class="string">"The slice after set value:%v \n"</span>, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<pre><code>The underlying array:[1 2 3 4 5 6 7 8 9 10]
The slice 1:[4 5 6 7 8 9 10], length:7, capacity:7
The slice 2:[5 6 7 8 9 10], length:6, capacity:6
The underlying array after set value for slice :[1 2 3 4 5 1000 7 8 9 10]
The slice 1 after set value:[4 5 1000 7 8 9 10]
The slice 2 after set value:[5 1000 7 8 9 10]
</code></pre><p>如果不想共享底层数据，可以使用内建的 <code>copy(resourceSlice, targetSlice)</code>函数 从原数组或者切片中拷贝一个新的切片，然后对新的切片的操作就不会因为共享底层数组影响其他切片了</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个集合中排除掉第二个集合后的结果</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Subtract</span><span class="params">(c1 []<span class="keyword">interface</span>&#123;&#125;, c2 []<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(subtraction []<span class="keyword">interface</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class="line">	subtraction = <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(c1))</span><br><span class="line">	<span class="built_in">copy</span>(subtraction, c1) <span class="comment">// copy c1 to subtraction</span></span><br><span class="line">	subtraction = c1[:]</span><br><span class="line">	<span class="keyword">for</span> _, elem2 := <span class="keyword">range</span> c2 &#123;</span><br><span class="line">		<span class="keyword">for</span> idx, elem1 := <span class="keyword">range</span> subtraction &#123;</span><br><span class="line">			<span class="keyword">if</span> elem2 == elem1 &#123;</span><br><span class="line">				subtraction = <span class="built_in">append</span>(subtraction[:idx], subtraction[idx+<span class="number">1</span>:]...)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在从数组或切片中生成新的切片的时候还可以指定新切片的容量<br>语法是<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newSlice := arr[start:end:<span class="built_in">cap</span>]</span><br></pre></td></tr></table></figure></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testSliceCap</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := []<span class="keyword">int32</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line">	s1 := a[<span class="number">2</span>:]</span><br><span class="line">	fmt.Printf(<span class="string">"a: %v, s1: %v\n"</span>, a, s1)</span><br><span class="line"></span><br><span class="line">	s2 := a[<span class="number">0</span>:<span class="number">2</span>:<span class="number">2</span>]</span><br><span class="line">	fmt.Printf(<span class="string">"a: %v, s2: %v\n"</span>, a, s2)</span><br><span class="line">	s2 = <span class="built_in">append</span>(s2, <span class="number">100</span>)</span><br><span class="line">	fmt.Printf(<span class="string">"a: %v, s1: %v, s2: %v\n"</span>, a, s1, s2)</span><br><span class="line"></span><br><span class="line">	s3 := a[:<span class="number">2</span>:<span class="number">2</span>]</span><br><span class="line">	s3 = <span class="built_in">append</span>(s3, <span class="number">101</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">"a: %v, s1: %v, s2: %v, s3:%v\n"</span>, a, s1, s2, s3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<pre><code>a: [1 2 3 4], s1: [3 4]
a: [1 2 3 4], s2: [1 2]
a: [1 2 3 4], s1: [3 4], s2: [1 2 100]
a: [1 2 3 4], s1: [3 4], s2: [1 2 100], s3:[1 2 101]
</code></pre><p>从上面的例子可以看到，限定了切片的容量之后，从同一数据产生的切片的</p>
<p><code>slice</code> 的基本操作和数组一致<br><code>slice</code> 不可以用 <code>==</code> 比较的， bytes 提供了 []byte 的比较方法, strings 提供了 []string 的比较方法</p>
<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>一个<code>无序</code>的K/V集合，其中所有的key 都是唯一的，在 <code>go</code> 中<code>map</code> 中的 <code>key</code> 必须是可比较的（支持 <code>==</code> 比较运算符）的数据类型, 所以 <code>key</code> 不能是 <code>map</code>、<code>slice</code> 或者 <code>func</code>, 而对于value 值没有任何要求</p>
<p>map 的定义和初始化</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mapDemo <span class="keyword">map</span>[Key]Value</span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[Key]Value, <span class="built_in">len</span>)</span><br></pre></td></tr></table></figure>
<p><code>map</code> 的 <code>key</code> 是完全无序的， 使用 <code>for</code> 循环遍历map 的时候每次的顺序都是随机的</p>
<p>判断 <code>map</code> m1 中是否包含 k1</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m1 = <span class="built_in">make</span>(<span class="keyword">map</span>[Key][Value])</span><br><span class="line">val1, contains := m1[k1]</span><br><span class="line"><span class="keyword">if</span> contains &#123;</span><br><span class="line">	fmt.Println(<span class="string">"the map m1 contains k1!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>注意：对于 <code>slice</code> 可以直接往为 <code>nil</code> 的 <code>slice</code> 中存放数据，但是map 必须先使用 <code>make</code> 分配内存</em></p>
<h4 id="结构体-struct"><a href="#结构体-struct" class="headerlink" title="结构体(struct)"></a>结构体(struct)</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个结构体</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	id <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义结构体的 String 函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Student)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">"name: %v, Id: %v"</span>, s.Name, s.id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化一个结构体</span></span><br><span class="line"><span class="keyword">var</span> s Student</span><br><span class="line"><span class="comment">// 访问结构体的数据</span></span><br><span class="line">s.Name = <span class="string">"test"</span></span><br></pre></td></tr></table></figure>
<p>结构体还可以组合, 下面我们尝试定义两个结构体，<code>Circle</code> 和 <code>Rectangle</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">	x, y, r <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">	x, y, <span class="built_in">len</span>, width <span class="keyword">int64</span> <span class="comment">// x,y 是左下角的点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 <code>Rectangle</code> 和 <code>Circle</code> 都具有点的属性，可以提取出一个结构体 <code>Point</code><br>下面的代码中我们定义了三个结构体，分别是 <code>Point</code>、<code>Circle</code>、<code>Rectangle</code>， 其中<code>Circle</code> 和 <code>Rectangle</code> 中都组合了一个 <code>Point</code>, 这是访问属性的时候就需要先访问被组合的结构体</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">	x, y <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">	c Point <span class="comment">// 原点</span></span><br><span class="line">	r <span class="keyword">int64</span> <span class="comment">// 半径</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 矩形</span></span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">	p          Point <span class="comment">// 左下角的点</span></span><br><span class="line">	<span class="built_in">len</span>, width <span class="keyword">int64</span> <span class="comment">// 长和宽</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c1 := Circle&#123;c: Point&#123;x: <span class="number">0</span>, y: <span class="number">0</span>&#125;, r: <span class="number">2</span>&#125;</span><br><span class="line">	fmt.Println(c1)</span><br><span class="line"></span><br><span class="line">	c2 := Circle&#123;&#125;</span><br><span class="line">	c2.c.x = <span class="number">0</span></span><br><span class="line">	c2.c.y = <span class="number">0</span></span><br><span class="line">	c2.r = <span class="number">3</span></span><br><span class="line">	fmt.Println(c2)</span><br><span class="line"></span><br><span class="line">	r1 := Rectangle&#123;p: Point&#123;x:<span class="number">0</span>, y:<span class="number">0</span>&#125;, <span class="built_in">len</span>:<span class="number">4</span>, width:<span class="number">3</span>&#125;</span><br><span class="line">	fmt.Println(r1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>go还支持在结构体中只声明属性的数据类型，而不只限定属性的名称, 这就是匿名成员，从下面的 代码中也能看到，匿名成员也不是没有名字，而是直接把数据类型作为了成员的名字</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">	x <span class="keyword">int64</span></span><br><span class="line">	y <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">	Point   <span class="comment">// 原点</span></span><br><span class="line">	r <span class="keyword">int64</span> <span class="comment">// 半径</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 矩形</span></span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">	Point            <span class="comment">// 左下角的点</span></span><br><span class="line">	<span class="built_in">len</span>, width <span class="keyword">int64</span> <span class="comment">// 长和宽</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c1 := Circle&#123;Point: Point&#123;x: <span class="number">0</span>, y: <span class="number">0</span>&#125;, r: <span class="number">2</span>&#125;</span><br><span class="line">	fmt.Println(c1)</span><br><span class="line"></span><br><span class="line">	c2 := Circle&#123;&#125;</span><br><span class="line">	c2.Point.x = <span class="number">0</span></span><br><span class="line">	c2.Point.y = <span class="number">0</span></span><br><span class="line">	c2.r = <span class="number">3</span></span><br><span class="line">	fmt.Println(c2)</span><br><span class="line"></span><br><span class="line">	r1 := Rectangle&#123;Point: Point&#123;x: <span class="number">0</span>, y: <span class="number">0</span>&#125;, <span class="built_in">len</span>: <span class="number">4</span>, width: <span class="number">3</span>&#125;</span><br><span class="line">	fmt.Println(r1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结构体是多个类型数据聚合的数据类型， 可以包含任何类型的属性，结构体的访问权限通过大小写来控制，只有大写开头的属性和结构体具有包外可见性，使用json序列化和反序列化数组的时候，小写开头的属性会被忽略。</p>
<p>结构体的比较取决于结构体的属性，当结构体的所有属性都是可比较的时候，结构体就是可比较的，当使用 <code>==</code> 比较两个结构体的示例的时候，这就是。针对包含不可比较的结构体，也可以使用<code>反射</code>的 <code>reflect.DeepEqual()</code></p>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>函数声明包括函数名、形式参数列表、返回值列表（可省略）以及函数体。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcName</span><span class="params">(param1 Type, param2 Type)</span> <span class="params">(result1 Type, result2 Type)</span></span> &#123;</span><br><span class="line">	<span class="comment">// method body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面的例子中，我们可以看到go 函数的一个显著特点：<code>多返回值</code>，<br>有时候一个方法的结果除了正常的结果外，还有不可预期的异常，这个时候就可以返回多个返回值，比如 <code>encode/json</code> 中的序列化的方法，正常情况下返回序列化的结果，而如果输入的参数无法序列化的时候则返回nil 和异常</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Marshal</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	e := &amp;encodeState&#123;&#125;</span><br><span class="line">	err := e.marshal(v, encOpts&#123;escapeHTML: <span class="literal">true</span>&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> e.Bytes(), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们在返回值列表中写明变量名，就可以在return 语句中省略操作数， 上面的方法就可以改写成下面这种</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Marshal</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(res []<span class="keyword">byte</span>, err error)</span></span> &#123;</span><br><span class="line">	e := &amp;encodeState&#123;&#125;</span><br><span class="line">	err = e.marshal(v, encOpts&#123;escapeHTML: <span class="literal">true</span>&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span>  <span class="comment">// 等同于 return nil, err</span></span><br><span class="line">	&#125;</span><br><span class="line">	res = e.Bytes()</span><br><span class="line">	<span class="keyword">return</span> <span class="comment">// 等同于 return e.Bytes(), nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="method-is-first-class-value"><a href="#method-is-first-class-value" class="headerlink" title="method is first-class value"></a>method is <code>first-class value</code></h5><p>在 go 语言中函数也是 <code>first-class value</code>， <code>first-class value</code> 的定义如下：</p>
<ul>
<li>可以作为变量或者数据结构存储</li>
<li>可以作为参数传递给方法/函数</li>
<li>可以作为返回值从函数/方法返回</li>
<li>可以在运行期创建</li>
<li>有固有身份；“固有身份”是指实体有内部表示，而不是根据名字来识别，比如匿名函数，还可以通过赋值叫任何名字。大部分语言的基本类型的数值(int, float)等都是第一类对象；但是数组不一定，比如C中的数组，作为函数参数时，传递的是第一个元素的地址，同时还丢失了数组长度信息。对于大多数的动态语言，函数/方法都是第一类对象，比如Python，但是Ruby不是，因为不能返回一个方法。第一类函数对函数式编程语言来说是必须的。</li>
</ul>
<p>也就是说在 go语言中函数拥有类型，可以被赋值，可以作为函数的参数或返回值，还可以有匿名函数</p>
<h5 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(args ...<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	total := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, a := <span class="keyword">range</span> args &#123;</span><br><span class="line">		total += a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(sum()) <span class="comment">// 0</span></span><br><span class="line">fmt.Println(sum(<span class="number">1</span>)) <span class="comment">// 1</span></span><br><span class="line">fmt.Println(sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)) <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">arr := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">fmt.Println(sum(arr...)) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<h5 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h5><p>有时候我们需要在函数执行结束之前释放资源（如数据库链接）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseFromFile</span><span class="params">(fileName <span class="keyword">string</span>)</span> <span class="params">(res []<span class="keyword">string</span>, err error)</span></span> &#123;</span><br><span class="line">    inputFile, err := os.Open(fileName)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"An error occurred on opening the inputfile\n"</span> +</span><br><span class="line">            <span class="string">"Does the file exist?\n"</span> +</span><br><span class="line">            <span class="string">"Have you got acces to it?\n"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inputReader := bufio.NewReader(inputFile)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        inputString, err := inputReader.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">				fmt.Printf(<span class="string">"The input was: %s"</span>, inputString)</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">						inputFile.Close()</span><br><span class="line">						<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">			  <span class="keyword">if</span> (err = checkLine(inputString)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					inputFile.Close()</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">				res = <span class="built_in">append</span>(res, inputString)     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在每个 <code>return</code> 语句之前，我们都需要调用 <code>inputFile.Close()</code>, 这样做是在太麻烦，go 为我们提供了 <code>refer</code> 关键字</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseFromFile</span><span class="params">(fileName <span class="keyword">string</span>)</span> <span class="params">(res []<span class="keyword">string</span>, err error)</span></span> &#123;</span><br><span class="line">    inputFile, err := os.Open(fileName)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"An error occurred on opening the inputfile\n"</span> +</span><br><span class="line">            <span class="string">"Does the file exist?\n"</span> +</span><br><span class="line">            <span class="string">"Have you got acces to it?\n"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">		refer inputFile.Close() <span class="comment">// 在函数执行到return 之前被调用</span></span><br><span class="line"></span><br><span class="line">    inputReader := bufio.NewReader(inputFile)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        inputString, err := inputReader.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">				fmt.Printf(<span class="string">"The input was: %s"</span>, inputString)</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">						<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">			  <span class="keyword">if</span> (err = checkLine(inputString)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">				res = <span class="built_in">append</span>(res, inputString)     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="refer-执行顺序"><a href="#refer-执行顺序" class="headerlink" title="refer 执行顺序"></a>refer 执行顺序</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	log.Printf(<span class="string">"this is func 1\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func2</span><span class="params">()</span></span> &#123;</span><br><span class="line">	log.Printf(<span class="string">"this is func 2\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func3</span><span class="params">()</span></span> &#123;</span><br><span class="line">	log.Printf(<span class="string">"this is func 3\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func4</span><span class="params">()</span></span> &#123;</span><br><span class="line">	log.Printf(<span class="string">"this is func 4\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	log.Printf(<span class="string">"begin\n"</span>)</span><br><span class="line">	<span class="keyword">defer</span> func1()</span><br><span class="line">	<span class="keyword">defer</span> func2()</span><br><span class="line">	<span class="keyword">defer</span> func3()</span><br><span class="line">	<span class="keyword">defer</span> func4()</span><br><span class="line">	log.Printf(<span class="string">"finished\n"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序的数据输出结果是：</p>
<pre><code>2018/04/17 08:11:41 begin
2018/04/17 08:11:41 finished
2018/04/17 08:11:41 this is func 4
2018/04/17 08:11:41 this is func 3
2018/04/17 08:11:41 this is func 2
2018/04/17 08:11:41 this is func 1
</code></pre><p>可以看出来：<code>defer</code> 的执行顺序和定义顺序正好是相反的</p>
<h5 id="循环中的-defer"><a href="#循环中的-defer" class="headerlink" title="循环中的 defer"></a>循环中的 defer</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// before process file</span></span><br><span class="line"><span class="keyword">for</span> _, filename := <span class="keyword">range</span> filenames &#123;</span><br><span class="line">		f, err := os.Open(filename)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> f.Close() <span class="comment">// <span class="doctag">NOTE:</span> risky; could run out of file</span></span><br><span class="line"><span class="comment">// ...process f</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// after process file</span></span><br><span class="line"><span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<p>在上面的程序中我们遍历文件名称数组，一个个的处理文件，并在处理完之后希望去关闭文件； 但是 <code>defer</code> 是在函数执行完最后一步才触发，如果文件比较多可能会耗光系统的文件描述符</p>
<p>这里的解决方案是把 for 循环的循环体抽取成函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, filename := <span class="keyword">range</span> filenames &#123;</span><br><span class="line">		<span class="keyword">if</span> err := doFile(filename); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doFile</span><span class="params">(filename <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		f, err := os.Open(filename)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">defer</span> f.Close()</span><br><span class="line">		<span class="comment">// ...process f…</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="init-函数"><a href="#init-函数" class="headerlink" title="init 函数"></a>init 函数</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// init something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>前面讲结构体的时候, 讲过可以给结构体定义方法, 事实上除了结构体我们还可以们可以给数值、字符串、map、数组定义一些自定义行为</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义int 数组</span></span><br><span class="line"><span class="keyword">type</span> array []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//给数组定义 sum 方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a array)</span> <span class="title">sum</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	total := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, i := <span class="keyword">range</span> a &#123;</span><br><span class="line">		total += i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> arr1 = array&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">	arrSum := arr1.sum()</span><br><span class="line">	fmt.Println(arrSum)  <span class="comment">// 输出 10</span></span><br><span class="line"></span><br><span class="line">	arrSum2 := array.sum(arr1) <span class="comment">// 常规调动函数的方法</span></span><br><span class="line">	fmt.Println(arrSum2)  <span class="comment">// 输出 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口类型具体描述了一系列方法的集合，一个实现了这些方法的具体类型是这个接口类型的实例。</p>
<ol start="2">
<li>内嵌结构体的函数</li>
<li>垃圾回收</li>
<li>协程池</li>
<li>并发</li>
<li>etcd</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://summerbuger.github.io/2018/01/10/技术-golang-2018-01-10-golang-工具/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liam Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPicture.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ice summer bug's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/10/技术-golang-2018-01-10-golang-工具/" itemprop="url">golang 工具</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-10T21:00:00+08:00">
                2018-01-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/golang/" itemprop="url" rel="index">
                    <span itemprop="name">golang</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="gofmt"><a href="#gofmt" class="headerlink" title="gofmt"></a>gofmt</h3><h3 id="go-install"><a href="#go-install" class="headerlink" title="go install"></a>go install</h3><h3 id="go-get"><a href="#go-get" class="headerlink" title="go get"></a>go get</h3><h3 id="go-build"><a href="#go-build" class="headerlink" title="go build"></a>go build</h3><h4 id="交叉编译-cross-compile"><a href="#交叉编译-cross-compile" class="headerlink" title="交叉编译 (cross compile)"></a>交叉编译 (cross compile)</h4><p>Golang 支持交叉编译，在一个平台上生成另一个平台的可执行程序，这里备忘一下。</p>
<p>Mac 下编译 Linux 和 Windows 64位可执行程序</p>
<pre><code>CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build main.go
CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build main.go
</code></pre><p>Linux 下编译 Mac 和 Windows 64位可执行程序</p>
<pre><code>CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build main.go
CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build main.go
</code></pre><p>Windows 下编译 Mac 和 Linux 64位可执行程序</p>
<pre><code>SET CGO_ENABLED=0
SET GOOS=darwin
SET GOARCH=amd64
go build main.go

SET CGO_ENABLED=0
SET GOOS=linux
SET GOARCH=amd64
go build main.go
</code></pre><p>GOOS：目标平台的操作系统（darwin、freebsd、linux、windows）<br>GOARCH：目标平台的体系架构（386、amd64、arm）<br>交叉编译不支持 CGO 所以要禁用它</p>
<h3 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://summerbuger.github.io/2017/12/10/技术-mac-linux-2017-11-24-MacOS常用指令/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liam Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPicture.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ice summer bug's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/10/技术-mac-linux-2017-11-24-MacOS常用指令/" itemprop="url">MacOS 系统常用指令</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-10T21:00:00+08:00">
                2017-12-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/shell/" itemprop="url" rel="index">
                    <span itemprop="name">shell</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="MacOS-常用指令"><a href="#MacOS-常用指令" class="headerlink" title="MacOS 常用指令"></a>MacOS 常用指令</h3><h4 id="查看cpu-个数"><a href="#查看cpu-个数" class="headerlink" title="查看cpu 个数"></a>查看cpu 个数</h4><pre><code>➜  ~ sysctl hw.physicalcpu
sysctl hw.logicalcpu
hw.physicalcpu: 4  # 物理cpu个数
hw.logicalcpu: 8   # 逻辑cpu个数
</code></pre><h4 id="查看系统用户"><a href="#查看系统用户" class="headerlink" title="查看系统用户"></a>查看系统用户</h4><pre><code>dscacheutil -q group #分组查看系统用户
dscacheutil -q user  #查看系统用户
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://summerbuger.github.io/2017/12/10/技术-kafka-2017-12-10-kafka如何把实现consumer控制offset/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liam Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPicture.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ice summer bug's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/10/技术-kafka-2017-12-10-kafka如何把实现consumer控制offset/" itemprop="url">kafka 中的偏移量</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-10T21:00:00+08:00">
                2017-12-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/kafka/" itemprop="url" rel="index">
                    <span itemprop="name">kafka</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="kafka-中的偏移量"><a href="#kafka-中的偏移量" class="headerlink" title="kafka 中的偏移量"></a>kafka 中的偏移量</h1><h2 id="首先来了解一下Kafka所使用的基本术语："><a href="#首先来了解一下Kafka所使用的基本术语：" class="headerlink" title="首先来了解一下Kafka所使用的基本术语："></a>首先来了解一下Kafka所使用的基本术语：</h2><p><code>Topic</code>: Kafka将消息种子(Feed)分门别类，每一类的消息称之为一个主题(Topic).</p>
<p><code>Producer</code>: 发布消息的对象称之为主题生产者(Kafka topic producer)</p>
<p><code>Consumer</code>: 订阅消息并处理发布的消息的种子的对象称之为主题消费者(consumers)</p>
<p><code>Broker</code>: 已发布的消息保存在一组服务器中，称之为Kafka集群。集群中的每一个服务器都是一个代理(Broker). 消费者可以订阅一个或多个主题（topic），并从Broker拉数据，从而消费这些已发布的消息。</p>
<hr>
<h2 id="话题和日志-Topic和Log"><a href="#话题和日志-Topic和Log" class="headerlink" title="话题和日志 (Topic和Log)"></a>话题和日志 (Topic和Log)</h2><p>让我们更深入的了解Kafka中的Topic。</p>
<p>Topic是发布的消息的类别或者种子Feed名。对于每一个Topic，Kafka集群维护这一个分区的log，就像下图中的示例：</p>
<p><img src="/assets/picture/kafka-partition.png" alt="图片" title="Kafka partition log"></p>
<p>每一个分区都是一个顺序的、不可变的消息队列， 并且可以持续的添加。分区中的消息都被分了一个序列号，称之为<code>偏移量</code>(offset)，在每个分区中此<code>偏移量</code>都是唯一的。</p>
<p>Kafka集群保持所有的消息，直到它们过期， 无论消息是否被消费了。 实际上消费者所持有的仅有的元数据就是这个<code>偏移量</code>，也就是消费者在这个log中的位置。 这个<code>偏移量</code>由<code>消费者</code>控制：正常情况当消费者消费消息的时候，<code>偏移量</code>也线性的的增加。但是实际<code>偏移量</code>由消费者控制，消费者可以将<code>偏移量</code>重置为更老的一个<code>偏移量</code>，重新读取消息。 可以看到这种设计对消费者来说操作自如， 一个消费者的操作不会影响其它消费者对此log的处理。</p>
<p><img src="/assets/picture/kafka-offset.png" alt="图片" title="Kafka partition offset"></p>
<hr>
<h2 id="消费者-Consumers"><a href="#消费者-Consumers" class="headerlink" title="消费者(Consumers)"></a>消费者(Consumers)</h2><p>通常来讲，消息模型可以分为两种， <code>队列</code> 和 <code>发布-订阅</code> 式。 队列的处理方式是 一组消费者从服务器读取消息，一条消息只有其中的一个消费者来处理。在发布-订阅模型中，消息被广播给所有的消费者，接收到消息的消费者都可以处理此消息。Kafka为这两种模型提供了单一的消费者抽象模型： 消费者组 （consumer group）。 消费者用一个消费者组名标记自己。 一个发布在Topic上消息被分发给此消费者组中的一个消费者。 假如所有的消费者都在一个组中，那么这就变成了queue模型。 假如所有的消费者都在不同的组中，那么就完全变成了发布-订阅模型。 更通用的， 我们可以创建一些消费者组作为逻辑上的订阅者。每个组包含数目不等的消费者， 一个组内多个消费者可以用来扩展性能和容错。正如下图所示：<br>2个kafka集群托管4个分区（P0-P3），2个消费者组，消费组A有2个消费者实例，消费组B有4个。</p>
<p><img src="/assets/picture/kafka-customer-type.png" alt="图片" title="Kafka customer type"></p>
<p>正像传统的消息系统一样，Kafka保证消息的顺序不变。 再详细扯几句。传统的队列模型保持消息，并且保证它们的先后顺序不变。但是， 尽管服务器保证了消息的顺序，消息还是异步的发送给各个消费者，消费者收到消息的先后顺序不能保证了。这也意味着并行消费将不能保证消息的先后顺序。用过传统的消息系统的同学肯定清楚，消息的顺序处理很让人头痛。如果只让一个消费者处理消息，又违背了并行处理的初衷。 在这一点上Kafka做的更好，尽管并没有完全解决上述问题。 Kafka采用了一种分而治之的策略：分区。 因为Topic分区中消息只能由消费者组中的唯一一个消费者处理，所以消息肯定是按照先后顺序进行处理的。但是它也仅仅是保证Topic的一个分区顺序处理，不能保证跨分区的消息先后处理顺序。 所以，如果你想要顺序的处理Topic的所有消息，那就只提供一个分区。</p>
<hr>
<h2 id="偏移量-Offsets-的管理"><a href="#偏移量-Offsets-的管理" class="headerlink" title="偏移量(Offsets)的管理"></a>偏移量(Offsets)的管理</h2><p>如上文所述，kafka为分区中的每条消息保存一个 <code>偏移量（offset）</code>，这个<code>偏移量</code>是该分区中一条消息的唯一标示符。也表示消费者在分区的位置。例如，一个位置是5的消费者(说明已经消费了0到4的消息)，下一个接收消息的偏移量为5的消息。实际上有两个与消费者相关的“位置”概念：</p>
<p>消费者的位置给出了下一条记录的偏移量。它比消费者在该分区中看到的最大偏移量要大一个。 它在每次消费者在调用poll(long)中接收消息时自动增长。</p>
<p>“已提交”的位置是已安全保存的最后偏移量，如果进程失败或重新启动时，消费者将恢复到这个偏移量。消费者可以选择定期自动提交偏移量，也可以选择通过调用commit API来手动的控制(如：commitSync 和 commitAsync)。</p>
<h3 id="消费者如何提交-偏移量-Offsets"><a href="#消费者如何提交-偏移量-Offsets" class="headerlink" title="消费者如何提交 偏移量(Offsets)"></a>消费者如何提交 <code>偏移量(Offsets)</code></h3><ol>
<li>自动提交</li>
</ol>
<p>这种方式只要在启动时配置属性 <code>enable.auto.commit</code> 为 <code>true</code> 即可， 示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">	props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"localhost:9092"</span>);</span><br><span class="line">	props.put(<span class="string">"group.id"</span>, <span class="string">"test"</span>);</span><br><span class="line">	props.put(<span class="string">"enable.auto.commit"</span>, <span class="string">"true"</span>);</span><br><span class="line">	props.put(<span class="string">"auto.commit.interval.ms"</span>, <span class="string">"1000"</span>);</span><br><span class="line">	props.put(<span class="string">"key.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">	props.put(<span class="string">"value.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">	KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line">	consumer.subscribe(Arrays.asList(<span class="string">"test"</span>));</span><br><span class="line">	System.out.println(consumer);</span><br><span class="line">	<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">	  ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</span><br><span class="line">	  <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">	    System.out.printf(<span class="string">"offset = %d, key = %s, value = %s%n"</span>, record.offset(), record.key(),</span><br><span class="line">	      record.value());</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>手动提交</li>
</ol>
<p>在一些场景中，<code>消费者</code> 需要自行判定消息是否被消费了，如果没有判断为没有消费（ps:可能是消费失败了，需要重试），<code>消费者</code> 不会改变 offset；只有 <code>消费者</code> 判定消费成功是，才手动调用 <code>commitSync()</code> 或 <code>commitAsync()</code> 方法去提交 <code>偏移量</code>； 当然此时我们需要把 <code>enable.auto.commit</code> 置为 false。</p>
<p>下面给出个小例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line"> props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"localhost:9092"</span>);</span><br><span class="line"> props.put(<span class="string">"group.id"</span>, <span class="string">"test"</span>);</span><br><span class="line"> props.put(<span class="string">"enable.auto.commit"</span>, <span class="string">"false"</span>); <span class="comment">// 主动提交置为false</span></span><br><span class="line"> props.put(<span class="string">"key.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line"> props.put(<span class="string">"value.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line"> KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line"> consumer.subscribe(Arrays.asList(<span class="string">"test"</span>));</span><br><span class="line"> System.out.println(consumer);</span><br><span class="line"> <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">	 ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</span><br><span class="line">	 <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">		 System.out.printf(<span class="string">"offset = %d, key = %s, value = %s%n"</span>, record.offset(), record.key(),</span><br><span class="line">			 record.value());</span><br><span class="line">		 <span class="comment">// 逻辑处理</span></span><br><span class="line">		 <span class="comment">// ...</span></span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="keyword">if</span> (success) &#123; <span class="comment">// 如果判定消费成功，则手动提交offset到 broker</span></span><br><span class="line">		 consumer.commitSync();</span><br><span class="line">	 &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="消费者如果控制偏移量"><a href="#消费者如果控制偏移量" class="headerlink" title="消费者如果控制偏移量"></a>消费者如果控制偏移量</h3><p>在一些场景下，消费者需要控制自己要读取的偏移量，此时用户可以通过API手动设置开始读取的 <code>偏移量</code></p>
<p>API 中提供以下方法：</p>
<ol>
<li><p>指定到某个分区的具体 offset<br>org.apache.kafka.clients.consumer.KafkaConsumer#seek(TopicPartition partition, long offset)</p>
</li>
<li><p>指定到某些分区的开始<br>org.apache.kafka.clients.consumer.KafkaConsumer#seekToBeginning(Collection<topicpartition> partitions)</topicpartition></p>
</li>
<li><p>指定到某些分区的结束，从上次结束的位置开始消费<br>org.apache.kafka.clients.consumer.KafkaConsumer#seekToEnd(Collection<topicpartition> partitions)</topicpartition></p>
</li>
</ol>
<p>此时我们需要知道当前的 <code>Topic</code> 的偏移量信息，<code>Kafka</code> 为我们提供了很友好的工具 <code>Get Offset Shell</code></p>
<p><code>Get Offset Shell</code><br>get offsets for a topic</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-run-class.sh kafka.tools.GetOffsetShell</span><br></pre></td></tr></table></figure>
<p>required argument [broker-list], [topic]</p>
<table>
<thead>
<tr>
<th>Option</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>–broker-list [hostname:port,….]</td>
<td>REQUIRED: The list of hostname and [hostname:port] port of the server to connect to.</td>
</tr>
<tr>
<td>–max-wait-ms [Integer: ms]</td>
<td>The max amount of time each fetch request waits. (default: 1000)</td>
</tr>
<tr>
<td>–offsets [Integer: count]</td>
<td>number of offsets returned (default: 1)</td>
</tr>
<tr>
<td>–partitions [partition ids]</td>
<td>comma separated list of partition ids. If not specified, will find offsets for all partitions (default)</td>
</tr>
<tr>
<td>–time [Long: timestamp in milliseconds]</td>
<td>-1(latest) / -2 (earliest) timestamp; offsets will come before this timestamp, as in getOffsetsBefore</td>
</tr>
<tr>
<td>–topic [topic]</td>
<td>REQUIRED: The topic to get offsets from.</td>
</tr>
</tbody>
</table>
<p>示例：</p>
<p>查询最近的offset</p>
<pre><code>➜  kafka_2.12-1.0.0 bin/kafka-run-class.sh kafka.tools.GetOffsetShell --broker-list localhost:9092 -topic test --time -1
</code></pre><p>输出</p>
<pre><code>test:0:52
</code></pre><p>查询开始的的offset</p>
<pre><code>➜  kafka_2.12-1.0.0 bin/kafka-run-class.sh kafka.tools.GetOffsetShell --broker-list localhost:9092 -topic test --time -2
</code></pre><p>输出</p>
<pre><code>test:0:0
</code></pre><h3 id="偏移量的存储"><a href="#偏移量的存储" class="headerlink" title="偏移量的存储"></a><code>偏移量</code>的存储</h3><p>新版本的 <code>Kafka</code> 将偏移量信息存储在名为 <code>__consumer_offsets</code> 的topic 中,<br>也支持将 <code>偏移量</code> 信息存储在 <code>Zookeeper</code> 中<br><br>通过设置属性 <code>offsets.storage</code> 控制，<code>offsets.storage</code> 属性可选值有 <code>kafka</code> 和 <code>zookeeper</code></p>
<p>消费者也可以不使用 <code>Kafka</code> 提供的偏移量存储方案，可自定义存储方式，详见<a href="http://kafka.apache.org/0101/javadoc/org/apache/kafka/clients/consumer/KafkaConsumer.html#rebalancecallback" title="官方文档" target="_blank" rel="noopener">官方文档</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://summerbuger.github.io/2017/12/06/技术-golang-2017-12-06-浮点数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liam Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headPicture.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ice summer bug's notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/06/技术-golang-2017-12-06-浮点数/" itemprop="url">浮点数学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-06T21:00:00+08:00">
                2017-12-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/golang/" itemprop="url" rel="index">
                    <span itemprop="name">golang</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="浮点数学习笔记"><a href="#浮点数学习笔记" class="headerlink" title="浮点数学习笔记"></a>浮点数学习笔记</h2><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>最近在工作中遇到汇率换算的问题，需要将用户订单中的的本币换算成美元，用 <code>golang</code> 写了个脚本进行换算，当把汇率变量的类型定义为 <code>float32</code> 的时候，计算结果存在不能接受的误差<br>查看了一下 <code>golang</code> 的官方文档，发现 <code>golang</code> 实现的浮点型数据是基于 <code>IEEE 754标准</code>，这一标准在存储小数的时候先天就 <code>存在误差</code>，下面会一一介绍。</p>
<h3 id="float-精度问题"><a href="#float-精度问题" class="headerlink" title="float 精度问题"></a><code>float</code> 精度问题</h3><p>先来个小例子，抛出问题</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a <span class="keyword">float32</span> = <span class="number">64.35</span></span><br><span class="line">	<span class="keyword">var</span> b = <span class="number">64.35</span>  <span class="comment">// 默认类型是 float64</span></span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">"this is a float32 %f \n"</span>, a)</span><br><span class="line">	fmt.Printf(<span class="string">"this is a float64 %f \n"</span>, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果：</p>
<pre><code>this is a float32 64.349998
this is a float64 64.350000
</code></pre><p>可以看到, 使用 <code>float32</code> 类型的时候， 小数 <code>64.35</code> 存储的并不精准；不难想象，对 <code>float32</code> 进行逻辑计算的时候肯定会产生误差；那么使用 <code>float64</code> 类型数据的时候，计算结果就一定精准吗？答案显然是<code>否定</code>的，下面给将给出答案</p>
<h3 id="为什么叫-浮点数"><a href="#为什么叫-浮点数" class="headerlink" title="为什么叫 浮点数"></a>为什么叫 <code>浮点数</code></h3><p>为什么叫 <code>浮点数</code>， <code>浮点数</code> 这个名词是相对 <code>定点数</code>来说的，从这两个名词中可以看出，这两个概念的差别就在于 <code>点</code>， 这里的 <code>点</code> 指的是小数中的 <code>小数点</code>；</p>
<p>大家都知道，计算机都是使用 <code>二进制</code> 的形式来存储和计算数据的，对于小数的处理也是如此；</p>
<p>存储小数的时候，计算机将小数分为 <code>整数</code> 和 <code>小数</code> 两个部分进行处理：</p>
<p><code>定点数</code> 就是将小数点的位置固定，分别分配固定的位数用于存储 <code>整数</code> 和 <code>小数</code> 部分，<br>例如，我们用 32bit 存储小数，第31位存储符号，23~30位存储 <code>整数</code>，0~22 位存储小数，如下图，</p>
<table>
<thead>
<tr>
<th>0</th>
<th>0000 1111</th>
<th>0100 0000 0000 0000 0000 000</th>
<th>15.25</th>
</tr>
</thead>
<tbody>
<tr>
<td>31bit符号位</td>
<td>23~30bit保存整数部分</td>
<td>0~22bit保存小数部分</td>
<td>十进制小数</td>
</tr>
</tbody>
</table>
<p>上面这个例子中 <code>定点数</code> 将小数点固定在 22bit 和 23bit 之间；可以很明显的看出，这种存储方式受到位数的限制，能表示的数字范围很小，上例中小数的范围就是 -255.xxx ~ 255.xxx <br><br>(ps：寡人太懒了，不想算[1/2 + 1/4 + … + 1/2<sup>-23</sup>])<br>也正是这个原因，计算机放弃了这种方式，采用了 <code>浮点数</code> 的方式。</p>
<p><code>浮点数</code> 从名称上来解释的就是，小数点的位置是浮动的；简单来说浮点数就是将一个数字用<code>科学计数法</code>表示，先将数字分为 <code>基数</code>、<code>指数</code>； 再将<code>基数</code>分为整数部分和小数部分，例如:<br>12345 = 1.2345 x 10<sup>4</sup>；当然这里是十进制，而计算机在存储<code>浮点数</code>的时候当然还是二进制</p>
<p>15.25 = 1111.01 = 1.11101 x 2<sup>3</sup></p>
<p>让我们用32bit 保存小数：</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1000 0010</th>
<th>1110 1000 0000 0000 0000 000</th>
<th>15.25</th>
</tr>
</thead>
<tbody>
<tr>
<td>31bit符号位</td>
<td>23~30bit保存指数部分</td>
<td>0~22bit保存小数部分</td>
<td>十进制小数</td>
</tr>
</tbody>
</table>
<p>你能从这个二进制中看出小数点的位置吗？<br><br>这里大家要注意： <strong>浮点数不仅仅可以保存小数！整数也是可以的</strong>，但是用浮点数表示整数这种行为不鼓励，毕竟浮点数表示数字是不精确的</p>
<h3 id="IEEE-754-存储-浮点数"><a href="#IEEE-754-存储-浮点数" class="headerlink" title="IEEE 754 存储 浮点数"></a><code>IEEE 754</code> 存储 <code>浮点数</code></h3><p>上面讲<code>浮点数</code>的时候也基本介绍了 <code>IEEE 754</code> 标准<br><br><code>IEEE 754</code> 标准依赖于 <code>科学计数法</code>，将一个数字用二进制科学计数法表示，将一个数字分为<code>指数</code>和<code>基数</code>，用一位表示符号位，再将基数分为整数（二进制的整数部分当然是1了）和小数部分；<code>IEEE 754</code>规定了四种表示浮点数值的方式：单精确度（32位）、双精确度（64位）、延伸单精确度（43比特以上，很少使用）与延伸双精确度（79比特以上，通常以80位实现）；如下：</p>
<table>
<thead>
<tr>
<th>表示方式</th>
<th>符号位（Sign,S）</th>
<th>指数部分(Exponent,E)</th>
<th>小数部分(Fraction,F)</th>
</tr>
</thead>
<tbody>
<tr>
<td>单精确度（32位）</td>
<td>1bit</td>
<td>8bit</td>
<td>23bit</td>
</tr>
<tr>
<td>双精确度（64位）</td>
<td>1bit</td>
<td>11bit</td>
<td>52bit</td>
</tr>
</tbody>
</table>
<p>一个单精确度（32位）浮点数的表达公式如下:<br><br><strong>ｘ＝(－1)<sup>S</sup>×(1.F)×2<sup>Ｅ－127</sup> 　 　e＝Ｅ－127</strong></p>
<p><code>Sign</code>: 简写为S，符号位，很简单就是 1:负数 0:正数<br><br><code>Exponent</code>: 简写为E，指数部分，计算公式是：<code>指数+接码偏移量(127)</code><br><br><code>Fraction</code>: 简写为F，小数部分</p>
<p>到这里大家就很自然的会想到一个问题 <strong>阶码偏移量为何用127?</strong></p>
<p>这个问题也困扰我很久，看了<code>维基百科</code>等资料，最后在<code>知乎</code>上找到了一个比较靠谱的答案，引用如下：</p>
<p>主要是为了让表示的范围能够对称起来<br>这个算一算就清楚了。当阶码E 为全0且尾数M 也为全0时，表示的真值x 为零，结合符号位S 为0或1，有正零和负零之分。当阶码E 为全1且尾数M为全0时，表示的真值x 为无穷大，结合符号位S 为0或1，也有+∞和-∞之分。这样在32位浮点数表示中，要除去E，用全0和全1(255)10表示零和无穷大的特殊情况，指数的偏移值不选128(10000000)，而127(01111111)。对于规格化浮点数，阶码E范围是1~254。 分两种情况计算如下： 1）偏移值为127时，绝对值范围大致是：1.2<em>10^(-38)~3.4</em>10^(+38)； 2）如果偏移值取为128时， 绝对值范围大致是：5.9<em>10^(-39)~1.7</em>10^(+38)； 可见偏移值取127时，上下范围基本对称，相对合理点。</p>
<p>作者：yuanyuany<br>链接：<a href="https://www.zhihu.com/question/24784136/answer/144601879" target="_blank" rel="noopener">https://www.zhihu.com/question/24784136/answer/144601879</a><br><br>来源：知乎</p>
<p>如果是双精确度（64位）</p>
<h3 id="十进制-和-IEEE-754浮点数-相互转化"><a href="#十进制-和-IEEE-754浮点数-相互转化" class="headerlink" title="十进制 和 IEEE 754浮点数 相互转化"></a><code>十进制</code> 和 <code>IEEE 754浮点数</code> 相互转化</h3><p>下面来个小例子， 我们将 <code>64.35</code> 转化成<code>IEEE 754浮点数</code></p>
<ol>
<li>现将 <code>64.35</code> 用转化成 <code>二进制</code></li>
</ol>
<p>先看整数部分 <code>64</code> = <code>0100 0000</code></p>
<p>再来转化小数部分转二进制</p>
<p>0.35x2 = 0.7  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   0 // 取计算结果整数部分<br><br>0.70x2 = 1.4  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   1 // 取上一计算结果的小数部分乘以2 <br><br>0.40x2 = 0.8  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   0 <br><br>0.80x2 = 1.6  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   1 <br><br>0.60x2 = 1.2  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   1 <br><br>0.20x2 = 0.4  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   0 <br><br>0.40x2 = 0.8  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   0 <br><br>0.80x2 = 1.6  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   1 <br><br>0.60x2 = 1.2  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   1 <br><br>0.40x2 = 0.8  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   0 // 到这里已经是循环重复了，这里永远不会算出1.0，所以用 <code>IEEE 754</code> 表示的时候是无限循环 <br></p>
<p>小数部分： <code>0.35</code> = <code>01 0110 0110 ...</code></p>
<p>二进制结果  <code>64.35</code> = <code>1000000.0101100110...</code> = <em><em>1.0000 0001 0110 0110 0110… x 2<sup>6</sup></em></em></p>
<p>用 32bit <code>IEEE 754</code> 存储 <code>64.35</code><br><br>s = 0<br><br>expr = 127 + 6 = 133 = <code>1000 0101</code> <br><br>frag = <code>0000 0001 0110 0110 0110 011</code><br></p>
<p><code>IEEE 754</code> 32位存储 <code>64.35</code> 的情况如下<br><br><code>64.35</code> = <code>0 | 1000 0101 | 0000 0001 0110 0110 0110 011</code></p>
<p>用 64bit <code>IEEE 754</code> 存储 <code>64.35</code><br><br>s = 0<br><br>expr = 1023 + 6 = 1029 = <code>1000 0000 0101</code> <br><br>frag = <code>0000 0001 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110</code><br></p>
<p><code>IEEE 754</code> 64位存储 <code>64.35</code> 的情况如下<br><br><code>64.35</code> = <code>0 | 1000 0000 0101 | 0000 0001 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110</code></p>
<p>我们再将<code>IEEE 754浮点数</code> 还原成小数,</p>
<p>先看看32bit 的情况<br>看看，算出指数  1000 0101 - 1111111 = 133 - 127 = 6<br><br>然后这个浮点数的二进制表示就是 <code>1.0000 0001 0110 0110 0110 011 x 2&lt;sup&gt;6&lt;/sup&gt;</code><br><br>下面就是换算成<code>十进制</code><br>1.0000 0001 0110 0110 0110 011 x 2<sup>6</sup> = 100 0000.0101 1001 1001 1001 1</p>
<p>先看整数部分  0100 0000 = 64<br>在看小数部分 0.0101 1001 1001 1001 1 转十进制</p>
<p>1/2<sup>2</sup> + 1/2<sup>4</sup> + 1/2<sup>5</sup> + 1/2<sup>8</sup> + 1/2<sup>9</sup> + 1/2<sup>12</sup> + 1/2<sup>13</sup> + 1/2<sup>16</sup> + 1/2<sup>17</sup> = 0.349052429199219</p>
<p>结论: <code>0 | 1000 0101 | 0000 0001 0110 0110 0110 011</code> = <code>64.349052429199219</code></p>
<p>再看 64bit 的情况：<br><br>1.0000 0001 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 x 2<sup>6</sup> = 100 0000.0101 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 10</p>
<p>0.0101 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 10 =<br>1/2<sup>2</sup> + 1/2<sup>4</sup> + 1/2<sup>5</sup> + 1/2<sup>8</sup> + 1/2<sup>9</sup> + 1/2<sup>12</sup> + 1/2<sup>13</sup> + 1/2<sup>16</sup> + 1/2<sup>17</sup> + 1/2<sup>20</sup> + 1/2<sup>21</sup> + 1/2<sup>24</sup> + 1/2<sup>25</sup> + 1/2<sup>28</sup> + 1/2<sup>29</sup> + 1/2<sup>32</sup> + 1/2<sup>33</sup> + 1/2<sup>36</sup> + 1/2<sup>37</sup> + 1/2<sup>40</sup> + 1/2<sup>41</sup> + 1/2<sup>44</sup> + 1/2<sup>45</sup> = 0.349999999999994</p>
<p>结论: <code>0 | 1000 0000 0101 | 0000 0001 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110</code> = <code>64.349999999999994</code></p>
<p>从这里也可以看出浮点数都不精确！当对精确有要求的时候尽量避免使用浮点数。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/headPicture.png"
                alt="Liam Chen" />
            
              <p class="site-author-name" itemprop="name">Liam Chen</p>
              <p class="site-description motion-element" itemprop="description">About technology and about life.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">40</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">27</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liam Chen</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
